# âš™ï¸ Day 11 â€” Mealy FSM: Sequence Detector '1001' (Overlapping)

## ğŸ“˜ Topics Understood

  * **Finite State Machines (FSMs)**
  * **Mealy Machine** 
  * **State Diagrams** and **State Tables**
  * **State Assignment** (`localparam`)
  * **Two-Process FSM Coding Style** (`always @(posedge clk)` and `always @(*)`)

-----

## ğŸ§  Description

A **Finite State Machine (FSM)** is a model used to design sequential circuits that exist in a finite number of states. The two types are:

1.  **Mealy Machine:** The output depends on the **present state** AND the **present input**.
2.  **Moore Machine:** The output depends **only on the present state**.

This project implements a **Mealy FSM** to detect the sequence `1001`. Because it's an "overlapping" detector, the '1' at the end of a successful `1001` sequence is also used as the *start* of the next potential `1001` sequence.

The design is implemented using two `always` blocks:

1.  A **sequential block** (`always @(posedge clk)`) to register the state.
2.  A **combinational block** (`always @(*)`) to determine the `nxt_state` and the `out`. This is characteristic of a Mealy machine, as the `out` logic reacts to the input `X` combinationally.

-----

## ğŸ§® Equations (State Logic)

The logic is defined by the state transitions rather than simple equations.

  * **State A (Idle):** Wait for '1'.
  * **State B (Seen '1'):** Wait for '0'.
  * **State C (Seen '10'):** Wait for '0'.
  * **State D (Seen '100'):** Wait for '1'. If '1' is received, output 1 and go to State B (for overlap).

-----

## ğŸ§© State Diagram

<img width="194" height="399" alt="image" src="https://github.com/user-attachments/assets/1c19c0df-73f2-43a7-ba18-dfa066e93e17" />

-----

## ğŸ§¾ Truth Table (State Table)

| **Present State** | **Input (X)** | **Next State** | **Output (out)** | **Description** |
|:---:|:---:|:---:|:---:|:---|
| A (`00`) | 0 | A (`00`) | 0 | Waiting... |
| A (`00`) | 1 | B (`01`) | 0 | Found '1' |
| B (`01`) | 0 | C (`10`) | 0 | Found '10' |
| B (`01`) | 1 | B (`01`) | 0 | Reset to '1' |
| C (`10`) | 0 | D (`11`) | 0 | Found '100' |
| C (`10`) | 1 | B (`01`) | 0 | Reset to '1' |
| D (`11`) | 0 | A (`00`) | 0 | Reset (sequence broken) |
| D (`11`) | 1 | B (`01`) | **1** | **Found '1001'** (overlap) |

-----

## ğŸ§¾ Verilog Design

  * **Design â€” `Day11/seq_dec_1001_mealy.v`**
  * **Testbench â€” `Day11/seq_dec_1001_tb.v`**

-----

## âš™ï¸ RTL Design (Synthesis)

  * The sequential block (`always @(posedge clk)`) synthesizes to **D-FlipFlops** (2 flip-flops for the 2-bit `state` register).
  * The combinational block (`always @(*)`) synthesizes to a cloud of **combinational logic** (multiplexers, AND/OR/NOT gates) that calculates the `nxt_state` and `out` signals based on the `state` and input `X`.

<img width="788" height="276" alt="image" src="https://github.com/user-attachments/assets/584a486d-2ae3-484e-ab22-2cc38f498e91" />

-----

## ğŸ“Š Waveform

The waveform for this testbench shows the input `X` changing *after* the positive clock edge. The FSM samples `X` at the *next* positive edge. When the input sequence `1-0-0-1` is completed, the `out` signal will go high for **one clock cycle**. Because it's a Mealy machine, the `out` signal is `1` during the *same cycle* that the final '1' is detected.

<img width="777" height="113" alt="image" src="https://github.com/user-attachments/assets/2a55a92d-dfe9-4346-8482-e9023e92a236" />

-----

## ğŸ” Observations

  * The output `out` is 1 when the sequence `1001` is detected.
  * **Mealy Output:** The output `out` is generated by the combinational logic. This means it can have glitches and is directly dependent on the input `X`. In the simulation, the `out=1` pulse appears *at the same time* as the final `X=1` input.
  * **Overlapping:** After the sequence `...1001...` is detected, the state machine moves to state `B`. This correctly uses the final '1' as the first '1' of the *next* sequence, demonstrating overlap.
  * The two-process style clearly separates the state storage (sequential logic) from the state/output calculation (combinational logic).

-----

## ğŸ§© Industry Relevance

  * FSMs are the "brain" of most digital control logic.
  * **Packet Processing:** Used in networking to parse packet headers and find specific data sequences.
  * **Protocol Handlers:** FSMs implement the logic for protocols like UART, SPI, I2C, and USB, managing the sequence of operations.
  * **CPU Control Units:** A CPU's main controller is a large FSM that moves through Fetch, Decode, and Execute states.

-----

  * âœ… **Status:** Completed
  * ğŸ—“ **Day:** 11 / 100
  * ğŸ“š **Next:** [Day 12 â€“ FSM (Traffic Controller) â†’](../Day12)
